# 函数式编程
## 高阶函数

* 变量可以指向函数  f = abs
* 函数名也是变量
* 传入函数
* 一个函数可以接收另一个函数作为参数，称为高阶函数

### map/reduce

* map()函数接收两个参数，一个是函数，一个是Iterable，map将传入函数依次作用到序列的每个元素，并把结果作为新的Iterable返回
* reduce把一个函数作用在一个序列上，这个函数必须接收两个参数，reduce把结果和序列的下一个元素做累积计算。
* reduce(f,[x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)

### filter

* 用于过滤序列
* 接收一个函数和序列，根据返回值是True还是False决定保留还是丢弃

### sorted

* 排序
* sorted()可以接收一个key函数来实现自定义排序

## 返回函数

* 函数作为返回值
* 闭包，返回闭包时不要引用任何循环变量，或者后续会发生变化的变量。或者在创建一个函数，参数绑定循环变量的当前值

## 匿名函数

* 关键字lambda,冒号前为参数，只能有一个表达式，不用写return，返回值就是该表达式的结果

## 装饰器

* 本质上，decorator就是一个返回函数的高阶函数
* functools.wraps()

## 偏函数

* 当函数的参数个数太多，需要简化时，使用functools.partial可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。

# 模块

* 包，模块

## 使用模块

* 模板
* 作用域 正常的函数和变量名是 public 的，通过加 _ 前缀是 private 的，而 _____xxx_____是特殊变量

## 安装第三方模块

* pip install numpy

# 面向对象编程
## 类和实例

* class Student(object):
* _____init____方法 ，参数 self 表示创建实例本身
* 类的方法 封装

## 访问限制

* 属性名称前加两个下划线 变私有
* 一个下划线 不要随意访问

## 继承和多态

* 定义class, 定义了一种数据类型，isinstance()判断
* 动态语言的鸭子类型

## 获取对象信息

* type()判断对象类型，isinstance()
* dir()获取对象所有属性和方法，返回一个包含字符串的list
* getattr(),setattr(),hasattr()操作对象的状态

## 实例属性和类属性

* 不要使用相同的名字

# 面向对象高级编程
## 使用 __slots__

* class 绑定方法
* 定义__slots__变量，来限制class实例能添加的属性
* 对继承的子类不起作用，除非子类也定义，这样可加上父类的

## 使用@property

* @property装饰器负责将一个方法变为属性调用
* getter方法变属性，只需要加上@property在前
* setter方法加@xxx.setter
* 只读属性 只定义getter方法

## 多重继承

* MixIn 给一个类增加多个功能

## 定制类

前有两个下划线
* str__ 方法 __repr__
* iter__ 迭代
* getitem__ 按照下标取元素
* getattr__ 不存在的属性  链式调用
* call__ 直接对实例进行调用

## 使用枚举类

* Enum类
* @unique装饰器 检查 是否 有重复值

## 使用元类

* 动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是运行时动态创建的。
* type()函数可以返回一个对象的类型，又可以创建出新的类型，传入三个函数
* class的名称
* 继承的父类集合
* class的方法名称与函数绑定
* type()函数允许动态创建类
* Metaclass 元类
* 两个下划线new__()方法接收到的参数依次是
* 当前准备创建的类的对象
* 类的名字
* 类继承的父类集合
* 类的方法集合
